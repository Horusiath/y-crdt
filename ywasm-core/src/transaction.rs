use js_sys::Uint8Array;
use std::convert::TryInto;
use std::ops::{Deref, DerefMut};
use wasm_bindgen::convert::{FromWasmAbi, IntoWasmAbi};
use wasm_bindgen::prelude::wasm_bindgen;
use wasm_bindgen::JsValue;
use yrs::updates::decoder::{Decode, DecoderV1};
use yrs::updates::encoder::{Encode, Encoder, EncoderV1, EncoderV2};
use yrs::{
    Origin, ReadTxn, StateVector, Store, Subdocs, Transact, TransactionMut, Update, WriteTxn,
};

#[wasm_bindgen]
pub struct Transaction(TransactionMut<'static>);

impl Deref for Transaction {
    type Target = TransactionMut<'static>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for Transaction {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl ReadTxn for Transaction {
    fn store(&self) -> &Store {
        self.0.store()
    }
}

impl<'txn> From<TransactionMut<'txn>> for Transaction {
    fn from(value: TransactionMut<'txn>) -> Self {
        Self(unsafe { std::mem::transmute(value) })
    }
}

impl WriteTxn for Transaction {
    fn store_mut(&mut self) -> &mut Store {
        self.0.store_mut()
    }

    fn subdocs_mut(&mut self) -> &mut Subdocs {
        self.0.subdocs_mut()
    }
}

#[wasm_bindgen]
impl Transaction {
    #[wasm_bindgen(getter, js_name = origin)]
    pub fn origin(&self) -> JsValue {
        self.deref().origin_js()
    }

    /// Encodes a state vector of a given ywasm document into its binary representation using lib0 v1
    /// encoding. State vector is a compact representation of updates performed on a given document and
    /// can be used by `encode_state_as_update` on remote peer to generate a delta update payload to
    /// synchronize changes between peers.
    #[wasm_bindgen(js_name = encodeStateVector)]
    pub fn state_vector(&self) -> Uint8Array {
        let sv = self.deref().state_vector();
        Uint8Array::from(sv.encode_v1().as_slice())
    }

    /// Encodes all updates that have happened since a given version `vector` into a compact delta
    /// representation using lib0 v1 encoding. If `vector` parameter has not been provided, generated
    /// delta payload will contain all changes of a current ywasm document, working effectivelly as its
    /// state snapshot.
    #[wasm_bindgen(js_name = encodeDocStateAsUpdate)]
    pub fn encode_doc_state(
        &self,
        state_vector: Option<Uint8Array>,
    ) -> Result<Uint8Array, JsValue> {
        let sv = decode_state_vector(state_vector)?;
        let mut encoder = EncoderV1::new();
        self.deref().encode_diff(&sv, &mut encoder);
        Ok(Uint8Array::from(encoder.to_vec().as_slice()))
    }

    /// Encodes all updates that have happened since a given version `vector` into a compact delta
    /// representation using lib0 v2 encoding. If `vector` parameter has not been provided, generated
    /// delta payload will contain all changes of a current ywasm document, working effectivelly as its
    /// state snapshot.
    #[wasm_bindgen(js_name = encodeDocStateAsUpdateV2)]
    pub fn encode_doc_state_v2(
        &self,
        state_vector: Option<Uint8Array>,
    ) -> Result<Uint8Array, JsValue> {
        let sv = decode_state_vector(state_vector)?;
        let mut encoder = EncoderV2::new();
        self.deref().encode_diff(&sv, &mut encoder);
        Ok(Uint8Array::from(encoder.to_vec().as_slice()))
    }

    /// Applies delta update generated by the remote document replica to a current document. This
    /// method assumes that a payload maintains lib0 v1 encoding format.
    #[wasm_bindgen(js_name = applyUpdate)]
    pub fn apply_update(&mut self, update: Uint8Array) -> Result<(), JsValue> {
        let data = update.to_vec();
        let update = Update::decode_v1(&data).map_err(|e| JsValue::from_str(&e.to_string()))?;
        self.deref_mut().apply_update(update);
        Ok(())
    }

    /// Applies delta update generated by the remote document replica to a current document. This
    /// method assumes that a payload maintains lib0 v2 encoding format.
    #[wasm_bindgen(js_name = applyUpdateV2)]
    pub fn apply_update_v2(&mut self, update_v2: Uint8Array) -> Result<(), JsValue> {
        let data = update_v2.to_vec();
        let update = Update::decode_v2(&data).map_err(|e| JsValue::from_str(&e.to_string()))?;
        self.deref_mut().apply_update(update);
        Ok(())
    }
}

fn decode_state_vector(state_vector: Option<Uint8Array>) -> Result<StateVector, JsValue> {
    if let Some(bytes) = state_vector {
        let bytes = bytes.to_vec();
        let mut decoder = DecoderV1::from(bytes.as_slice());
        match StateVector::decode(&mut decoder) {
            Ok(sv) => Ok(sv),
            Err(e) => return Err(JsValue::from_str(&e.to_string())),
        }
    } else {
        Ok(StateVector::default())
    }
}

trait TransactWithJsOrigin: Transact {
    fn transact_mut_with_js(&self, origin: JsValue) -> Transaction {
        let abi = origin.into_abi();
        let txn = self.transact_mut_with(abi);
        Transaction::from(txn)
    }
}

impl<T: TransactWithJsOrigin> TransactWithJsOrigin for T {}

pub(crate) trait JsOriginProvider {
    fn origin(&self) -> Option<&Origin>;

    fn origin_js(&self) -> JsValue {
        let abi = if let Some(origin) = self.origin() {
            let bytes: [u8; 4] = origin.as_ref().try_into().unwrap();
            u32::from_be_bytes(bytes)
        } else {
            0
        };
        unsafe { JsValue::from_abi(abi) }
    }
}

impl<'txn> JsOriginProvider for TransactionMut<'txn> {
    fn origin(&self) -> Option<&Origin> {
        self.origin()
    }
}
